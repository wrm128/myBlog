<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>《代码整洁之道》读书笔记</title>
      <link href="/2018/07/14/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/14/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>[toc]</p><p>最近在阅读《Clean Code》，读书笔记记录于此。</p><h2 id="什么样的代码是好代码？"><a href="#什么样的代码是好代码？" class="headerlink" title="什么样的代码是好代码？"></a>什么样的代码是好代码？</h2><ul><li>好代码让人赏心悦目</li><li>完成功能 - 基本要求</li><li>划分合理 - 低耦合、高内聚</li><li>风格规范 - 代码易阅读、易维护</li><li>实现高效 - 性能好</li><li>简洁实用 - 避免过度设计、避免炫技</li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>使用读得出来的名称</li><li>避免过度缩写，例如genymdmhs</li><li>名称的长短应与其作用域大小一致</li><li>越是作用域大的变量的名字越应该清晰地描述其含义，便于搜索</li><li>避免使用编码</li><li>无需将类型或作用域等编码进变量名中，如 f_price, g_count, m_name…，否则变量类型修改之后，变量名也需要跟着更新，否则就会误导读者</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数的第一规则是要短小；第二规则是还要更短小</li><li>最好不要超过100行，20行封顶最佳</li><li>避免过多嵌套：函数的缩进层级不应该多于1层或2层</li><li>函数应该做一件事。做好这件事。只做这一件事。</li><li>函数参数越少越好，应尽量避免三个及以上的参数。</li><li>参数数目越少，测试时需要覆盖的场景数越少，越方便测试</li><li>尽量避免使用参数进行信息输出，最好直接用返回值进行输出<ul><li>有时候返回值比放在参数中多了一次拷贝？？？ RVO, NRVO</li></ul></li><li><p>使用异常代替返回错误码 ？</p><ul><li>忘了在哪本书里面看的，说C++里面尽量避免使用异常？？感觉本书主要针对java编程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    logger.<span class="built_in">log</span>(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述代码 错误处理与正常流程被混为一谈。。。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Page page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        deletePageAndAllReferences(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        logError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deletePageAndAllReferences</span><span class="params">(Page page)</span> throws Exception </span>&#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    logger.<span class="built_in">log</span>(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述拆分在java中固然好。。但在C++中就不能不在每个子函数内部添加try&#123;&#125;catch()&#123;throw...&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>从一开始就尽量遵照规则写好每一个函数？还是先完成功能，再打磨、重构、组装成遵循规则的函数？</p></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释本身就是一种失败？是一种代码表达能力低的表现？</li><li>注释不能美化糟糕的代码；尽量用代码来阐述；避免不必要的注释</li><li>不必为了注释而注释</li><li>注释也会说谎，尤其当注释没能被持续维护的情况下</li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li>纵向格式<ul><li>不同的思路或表达之间应该用空白行区隔开</li><li>紧密相关的代码应该相互靠近</li><li>若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。</li></ul></li><li>横向格式<ul><li>一行代码不要超过120个字符</li><li>根据运算符的优先级进行空格, e.g. a*b + c*d  vs.  a * b + c * d</li></ul></li></ul><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ul><li>对象把数据隐藏于抽象之后，曝露操作数据的接口；数据结构曝露其数据，没有提供有意义的函数。</li><li>过程式代码（使用数据结构）便于在不改变现有数据结构的前提下添加新函数，面向对象代码便于在不改变既有函数的前提下添加新类。过程式代码难以添加新数据结构，因为必须修改所有函数；面向对象代码难以添加新函数，因为必须修改所有类。实际使用时需要根据情况进行选择（希望灵活地添加数据类型？还是操作行为？）。</li><li>The Law of Demeter：模块不应该了解它所操作对象的内部情形。方法不应调用由任何函数返回的对象的方法。</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>错误处理很重要，但如果他搞乱了代码逻辑，就是错误的做法</li><li>可控异常违反了开放／封闭原则。如果你在方法中抛出可控异常，而catch语句在三个层级之上，你就需要在catch语句和抛出异常处之间的每个方法签名中声明该异常。这意味着对软件较低层级的修改，都将波及较高层级的签名。</li><li>将第三方api打包是个良好的实践手段。当你打包一个第三方api，你就降低了对它的依赖：未来你可以不太痛苦地改用其他代码库。</li><li>不要返回或者传递null值。返回null值，等于在给调用者添乱，试想如果有一处没有进行null检查，应用程序就会失控<ul><li>可以抛出异常，或者返回特例</li></ul></li><li>如果将错误处理隔离看待，独立于主要逻辑之外，就能写出鲁棒而整洁的代码。</li></ul><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2>]]></content>
      
      <categories>
          
          <category> software engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> engineer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>201 principles of software development</title>
      <link href="/2018/05/21/201-principles-of-software-development/"/>
      <url>/2018/05/21/201-principles-of-software-development/</url>
      <content type="html"><![CDATA[<h1 id="软件开发中的201条原则"><a href="#软件开发中的201条原则" class="headerlink" title="软件开发中的201条原则"></a>软件开发中的201条原则</h1><p>本文翻译自《201 principles of software development》</p><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ol><li>质量第一。</li><li>不同的人对软件质量的定义不同。对于开发者来说，质量意味着优雅的设计和编码；对于高压环境下的用户来说，质量意味着响应时间和容量；对某些客户来说，质量意味着满足所有已知的和未知的需求…一个项目的质量取决于它需要优先考虑的事以及各参与方。</li><li>产量和质量不可兼得。产量越高，则质量越低。贝尔实验室发现，要想实现每千行代码只有1～2个bug，那么每人月只能产出150～300行代码。</li><li>高质量的软件是可以实现的。大型的软件系统是能以很高的质量构建的，但必须以很高的价格：每行代码$1000。作为开发者，要知道那些能够提高软件质量的技术：多与用户沟通，构建原型，保持设计简单，检查，雇佣最优秀的人…</li><li>不要试图改造软件质量。就好比不要试图把一个测试原型(throwaway prototype)转化成产品一样。</li><li>可靠性差比效率低更可怕。</li><li>尽早交付产品。可以尽快构建一个原型，让用户体验，一方面能早日收集到反馈，一方面可以验证需求，便于后续开发出令用户满意的产品。</li><li>与客户/用户沟通。人和环境都可能发生变化，跟进变化的唯一方法就是交流。</li><li></li><li></li><li></li><li>13.</li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li>27.</li><li></li><li></li><li></li><li></li><li></li><li></li><li>35.</li><li>37.</li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li></li></ol><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><ol><li>把需求文档转变成设计文档并不是一件容易的事儿</li><li>跟踪每一个需求，记录每一个需求的设计及实现情况（可以用表格来记录）</li><li>评估每一种方案，从中选出最好的</li><li>没有文档的设计不算真正的设计</li><li>封装，便于维护以及隔离错误</li><li>不要重复造轮子</li><li>KISS(Keep It Simple, Stupid)原则，即 保持简洁和单纯</li><li>避免过多的特殊情况：如果需要考虑的特殊情况太多，说明设计或算法有问题</li><li>最小化计算机世界与现实世界的距离，即 在选择模型和方法时尽可能地模拟现实世界</li><li>保持设计的智能可控性，本质上是倡导分层设计，并提供多种视角 (-&gt;80)</li><li>保持概念完整性，包括数据结构的组织、模块间的通信方式、错误警告等等的一致性。即使是由多个人开发的系统，看起来也像一个人开发的一样。</li><li>概念错误比语法错误更重要、更难以排查。</li><li>松耦合，高内聚</li><li>为改变而设计，即 所作的设计必须能够适应变化的需求：模块化、可移植、可扩展、贴近现实(69)、智能可控(70)、概念完整(71)</li><li>设计需要考虑后期维护。就可维护性而言，架构的选择比算法和代码更重要。</li><li>设计需要考虑错误情况。尽量做到：<pre><code>1. 不引入错误2. 引入的错误很容易检测到3. 部署后依然存在的错误要么不重要，要么能够避免执行过程中出现灾难性问题</code></pre>有些具体方法可以帮助提高设计的鲁棒性：<pre><code>1. 不要遗漏任何一种状态，例如一个变量有4种取值，不要只检查其中的3种2. 预测尽可能多的“impossible”的情况，并给出恢复策略3. 为了排除引发灾难的情况，使用故障树(fault tree)分析预测不安全的情形</code></pre></li><li>构建通用性软件。通用性强的软件/组件一般运行会稍微慢一些。</li><li>构建灵活性软件。灵活性强的组件一般比通用性强的组件运行更高效。</li><li>使用高效的算法。要求设计者了解各种算法并能够进行算法复杂度分析。</li><li>模块规格说明应该包含用户需要的所有信息，不要加入用户不需要的任何信息。即模块化。</li><li>设计是多维度的，包括 打包(packaging, what is part of what), 分层(hierarchy, who needs whom), 调用(invocation, who invokes whom), 流程(processes)…</li><li>伟大的设计来自于伟大的设计者</li><li>了解你的应用程序，例如压力环境下的预期行为、输入频率、响应时间、天气的影响…等等</li><li>可以复用一些模块或组件，因为复用的成本小且效率高。</li><li>对于软件来说”garbage in, garbage out”是不正确的。对于无效的输入，软件应该给出智能的回应，指出为什么无效；并且不应该进行处理，而是返回错误码，避免错误向后扩散。</li><li>可以通过冗余来实现软件可靠性：<ol><li>并行策略，例如mr任务，每个分片的job都会起多个相同的、互不影响的task，如果其中一个跑完了，就可以kill掉其他的了</li><li>冷备，当主控机器出现硬件故障时，可以启动备用机器继续提供服务<br>软件的高可靠性需要很高的代价，有时针对一套需求可能需要提供两套设计方案。</li></ol></li></ol><h2 id="编码原则"><a href="#编码原则" class="headerlink" title="编码原则"></a>编码原则</h2><p>87. 避免花招（avoid tricks）</p><pre><code>- 许多程序员喜欢在编码时使用一些奇淫技巧以显示他们的聪明才智，但这无疑降低了代码的可读性和可维护性</code></pre><p>88. 避免全局变量<br>89. 自上而下写代码</p><pre><code>- 人们习惯从上到下阅读代码，因此编码时要能够便于读者理解。自上而下编码包括：    1. 文件头部要添加详细的注释，以说明程序的用途和用法    2. 预先指定外部访问的程序、变量、算法    3. 采用结构化编程方法</code></pre><p>90. 避免副作用（avoid side-effect）</p><pre><code>- 程序的副作用是指程序基本功能之外的一些效果，且在程序外部是可见可感知的 ？？？副作用是软件中很多微小错误的来源,是最难发现的一类错误。</code></pre><p>91. 使用有意义的名字</p><pre><code>- 无意义的缩写命名，例如&quot;N_FLT&quot;,&quot;F&quot;，看似减少了按键次数，其实是降低了开发效率：    1. 测试和维护风险增加，因为人们需要花很多时间去猜测和理解命名    2. 对于无意义的缩写，因为需要添加注释来解释命名，总的按键次数反而增加了- 好的程序员应该只用10～15%的时间来打字(typing)，其他大部分时间用来思考(thinking).</code></pre><p>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.</p><h2 id="测试原则"><a href="#测试原则" class="headerlink" title="测试原则"></a>测试原则</h2><h2 id="管理原则"><a href="#管理原则" class="headerlink" title="管理原则"></a>管理原则</h2><p>管理包含软件开发周期中的一系列活动，包括规划、控制、监督、汇报等。</p><p>127. 好的管理比好的技术更重要</p><pre><code>1. 好的管理可以激励人们做到最好；相反，差的管理会使人们失去动力2. 并没有普遍适用的正确的管理风格；管理风格可以因时因地因人而异，重点在于必须适应其所在的环境。</code></pre><p>128. 采用合适的解决方法：技术问题需要技术方案，政治问题需要政治解决，管理问题需要合适的管理方法。<br>129. 不要对你读到的所有内容都深信不疑</p><pre><code>1. 当一个人相信某个哲理时，他倾向于寻找能够支撑这个哲理的数据，而丢弃那些不支持该哲理的数据2. 当你读到“你可以用方法X得到93%的提高(产量or质量)”时，这个方法或许能够达到预定的结果，但也可能存在例外。很大可能是，大部分工程都达不到如此戏剧性的结果；甚至，有些工程使用方法X后产量还降低了。</code></pre><p>130. 理解客户的优先级</p><pre><code>1. 你可以从需求分析中获知一些用户的优先级信息，难的是如何理解那些可能会发生变化的优先级2. 另外，要理解用户所说的基本的(essential)、期望的(desirable)、可选的(optional)的需求。试想，如果只完成了基本需求，而没有完成任何期望的或者可选的需求，用户会满意吗？ </code></pre><p>131. 人才是成功的关键</p><pre><code>1. 有经验、有才华的高技术人才是按时按预算完成软件的关键。正确的人选，即使在工具/语言/方法有限的情况下也能成功；而错误的人选，即使在工具等资源充足的情况下也可能失败。2. 根据COCOMO模型，最好的人选有4倍于其他人的效率；所以及时那个人需要4倍于他人的薪水，你也没有吃亏；如果他要的更少，你不仅节约了成本还得到了好的产品。</code></pre><p>132. 少量有技术的人比大量没有技术经验的人要好</p><pre><code>1. 与其投入大量没有经验的工程师，不如分配给几个好的、有经验的工程师2. 另外，为了避免几个好的工程师都离开，应该对人员配置进行适当的混合，尤其注意不要太偏向于任何一个人</code></pre><p>133. 倾听你的队员：如果你和团队成员之间没有信任，那么你们的项目必将失败。信任的第一原则就是倾听。<br>134. 相信你的队员</p><pre><code>1. 相互信任是成功的管理的基本要素。如果你相信你的队员，他们就会值得你信任；如果你表现出不信任他们，他们也会给你不信任他们的理由。信任是相互的，当你相信他们，并且让他们没有理由不相信你时，他们就会信任你。2. 当你的一个员工跟你说：“我今天下午可以2点离开吗？本周的后面几天我会多工作几个小时补回来的”，此时你应该说“可以”。你什么都没有失去，反而赢得了员工的忠诚和尊敬。你扮演坏人的机会要远多于扮演好人的机会，因此抓住每一个可以做好人的机会。说不定哪一天，你就需要那个员工加几个小时的班以便帮忙完成任务。</code></pre><p>135. 期望优秀和卓越</p><pre><code>1. 当你对员工抱有很高的期望时，他们会做的更好！在很多实验中，将一群人分成两个组，给他们定下相同的目标，对第一组表现出很高的期望，同时表现出视第二组为平庸之辈，这种情况下，第一组总是会比第二组做的更好！2. 如何表现出你对他们有很高的期望呢？你可以以身作则，树立榜样（如努力工作，不在工作期间玩游戏...）；给员工提供教育福利以帮助他们取得最好的成绩；嘉奖优秀的行为；鼓励表现差的员工养成更好的习惯、作出更好的产品，即使没能引导他们做的更好，也可以帮他们寻找其他合适的机会（公司内外）。你不能允许他们一直待在不合适的岗位上，但你也要表现出同情和理解。</code></pre><p>136. 沟通技巧很重要：招聘过程中不能低估沟通和协作的重要性<br>137. 帮忙打水</p><pre><code>1. 当你的员工正在加班完成一个项目时，你应该和他们工作相同的时间。2. 即使无法提供工程上的帮助，也要让他们知道你与他们同在：帮忙订披萨，买苏打水，带水等，一切他们需要的事情...</code></pre><p>138. 给不同的员工以不同的激励</p><pre><code>1. 不同的人想要的激励可能是不同的，有的想要加薪，有的想要升职，有的或许只想要一台高性能的电脑...2. 想要发现激励每个人的因素并不是一件简单的事，一个比较好的方法就是倾听，剩下的就是去尝试。但不管怎样，都不要因为怕选择错误的激励方式而放弃提供嘉奖。</code></pre><p>139. 保持办公环境的安静</p><pre><code>- 高效的员工和公司都会提供安静的、私有的办公环境；与之对应的是大部分企业都是开放的景观办公室，降低了物理设备成本，说是方便沟通，但其实是方便了噪音和干扰，严重影响了生产力和质量</code></pre><p>140. 人力和时间是不能互换的</p><pre><code>- 布鲁克斯法则(Brook&apos;s Law)指出，投入更多的人来开发一个紧急的项目只会让进度更慢，更多并不意味着更好。投入新的人力时，要考虑训练和沟通成本。</code></pre><p>141. 不同软件工程师之间的差别是很大的</p><pre><code>- 最好的软件工程师和最差的软件工程师在产量（每人月代码行数）上能相差25倍，软件质量（每1000行代码的bug数）上能相差10倍</code></pre><p>142. 可以优化任何方面</p><pre><code>- 当你告诉员工 排期、软件大小、软件性能、可维护性、用户友好性都同等重要时，那么很可能哪方面都没有得到优化。当你告诉他们其中的一项或者两项比较重要时，可能只有重要的因素得到了优化。事实上在软件开发的过程中，这些因素的优先级可能会不断调整，需要进行不同的折中（trade-offs)，你应该让员工理解这些优先级变化以及用户需求。</code></pre><p>143. 自动收集工程师数据</p><pre><code>- 收集工程师相关的数据有助于将来进行成本预测、评估项目状态和进展、评估改变（管理／技术/..）方案的影响。但数据收集应该尽可能自动化，最主要的是不唐突、不要让开发人员感到困扰。</code></pre><p>144. 考虑每行代码的成本是没有意义的</p><pre><code>- 相同的需求，可以使用不同的编程语言来完成。通常，使用高级语言会比低级语言节省开发时间，且缩短代码量；但由于用户文档、需求文档、设计文档等成本是固定的，最终会导致前者的单行代码成本增加。</code></pre><p>145. 没有完美的衡量开发效率的方法</p><pre><code>1. SLOC(source lines of code)代码行估算法：大家普遍认为代码产出越多越好，但有时候却并非如此。实现相同的功能，代码量肯定越少越好。2. FP(function points)功能点估算法：大家可能认为功能点越多表示产出越多、效率越高，但所要解决的问题的复杂程度或难度不同也是会影响产出率的。3. 没有哪一种方法是完美的，也不要单独依赖一种方法进行考量。</code></pre><p>146. 调整成本估算方法</p><pre><code>- 市面上有很多成本估算方法，每个方法都是基于大量已经完成的项目提炼出来的。你可以用这些方法估算大致的成本，但若想获得更准确的结果，则需要对模型或方法进行调整，使其适应你的工作环境（包括你的团队、你的产品等各种因素）。</code></pre><p>147. 不要设定不切实际的deadline</p><pre><code>- 不切实际的deadline会消解士气、降低员工对你的信任、导致员工离职等，会产生很多负面影响。这类deadline基本都无法达到，即使达到了，产品质量也无法保证，最终导致团队在整个软件领域的信誉度下降。</code></pre><p>148. 避免不可能</p><pre><code>- 从写需求分析文档到软件交付所需要的时间不会少于人月立方根的2.15倍，即 $T &gt; 2.15 * \sqrt[3]{PM}$，因此不要制定不可能完成的计划</code></pre><p>149. 使用之前必须了解</p><pre><code>- 例如，在你在选择一套度量指标之前，你必须确保它能够度量你所想测的东西并能够达到你的目标</code></pre><p>150. 收集生产数据：</p><pre><code>- 没有历史生产数据就没有办法进行成本估算模型的调整和训练，也就不能进行准确的成本估计，因此数据收集要从平时做起。</code></pre><p>151. 不要忘记团队生产力</p><pre><code>- 相比团队生产力来说，个人生产力比较容易衡量。但是，提高每个成员的生产力并不一定能够提高整个团队的生产力。例如一个篮球队，每个球员的投篮命中率都很高，但并不意味着这个球队就能赢。可以从一段时间内团队解决突出问题的能力、所解决问题的难度等方法来考察团队效率。</code></pre><p>152. 代码行数取决于编程语言</p><pre><code>- 使用高级语言的效率一般会明显高于低级语言，例如500行Ada代码比500行汇编代码能实现更多的功能</code></pre><p>153. 相信设定的时间表</p><pre><code>1. 一旦制定好了计划和排期，就需要所有员工相信这个时间表的可行性，否则就很难成功。2. 一个建议就是让工程师们来设定时间表，这种方法并非总是可行；另一个建议就是让工程师参与到时间表的制定中来，尤其需要在功能点、排期、放弃项目之间作出选择和折衷时。</code></pre><p>154. 精心计算的成本估计也不是万无一失的</p><pre><code>- 即使一个精心设计的估算模型得出的估算结果也未必准确。这里面有三个因素：（1)你 （2）假设条件 （3）概率。你的领导能力对结果影响很大，你可以在5秒钟摧毁你们团队1年建立起来的文化；你在进行估算时所作的前提假设可能会使结果不准确，如果你的需求变更了呢，如果你的核心成员生病了呢；估算结果只是整个概率分布中的一个峰值，其发生也是需要一定概率的。</code></pre><p>155. 定期评估时间表</p><pre><code>- 每个阶段的工作完成后都应该重新评估时间表，如果有delay的话，则需要及时调整时间表，不要妄图在后面的阶段追赶上来，否则只会让delay升级。试想如果每个阶段的期限都错过了，那么最后留给测试的时间就会越来越少，这样就可能出现两种不可避免的结果：（1）交付一个质量没有保障的产品，（2）客户在项目后期才了解到产品出现了很大的delay。因此，应该及时与业务方或上级领导沟通，告知他们排期的变动，并商讨对策，以降低损失。</code></pre><p>156. 轻微的低估并非总是坏事</p><pre><code>- 轻微的低估导致的轻微的delay能够督促队员更加努力赶上进度，从而提高生产力。注意，不能是明显的低估成本！</code></pre><p>157. 合理分配资源</p><pre><code>- 人为约束的时间表和不合理的预算都会导致项目的失败，不要试图压缩时间表和预算，否则最终可能需要付出比正常情况更多的成本。</code></pre><p>158. 详细地计划项目</p><pre><code>- 每个项目都需要一个计划，计划的详细程度取决于项目的复杂程度。项目越复杂，则需要计划越详细。    - 用PERT(Program Evaluation and Review Technique)图来表示各任务之间的依赖关系    - 用GANTT甘特图来显示每个任务的开始时间、结束时间及中间进度    - 设立一系列可实现的阶段性目标(milestones)    - 设定文档和代码编写规范    - 合理的人员及任务分配</code></pre><p>159. 及时更新你的计划<br>160. 避免驻波</p><pre><code>- 出现问题（delay、需求变更）及时调整计划和排期，不要等问题越积越多，越变越大</code></pre><p>161. 了解十大风险</p><pre><code>1. 人员短缺2. 不切实际的时间表3. 不理解需求4. 构建了一个糟糕的用户界面5. 试图增加用户不想要的feature6. 没有把握需求变化7. 缺少可重用的接口或组件8. 缺少可外部执行的任务9. 响应时间太差10. 试图超过当前的计算机技术</code></pre><p>162. 预先了解风险</p><pre><code>- 项目初期，可以列出那些可能出现的比较大的风险，并量化其影响以及其出现的概率。可以构建一棵决策树来描述可能的风险以及规避／降低风险的方法。</code></pre><p>163. 选择合适的开发模型</p><pre><code>- 软件开发模型有很多：瀑布模型、抛弃型原型、增量开发、螺旋模型、业务原型等，但没有哪种模型能适用于所有项目。模型的选择可以基于公司文化、风险意愿、应用领域、需求波动以及对需求的理解程度等因素。</code></pre><p>164. 方法并不能拯救你</p><pre><code>- 方法并不是万能的。如果一个团队以前使用结构化的方法无法开发出高质量的软件，那么现在用面向对象的方法还是无法开发出高质量的软件，因为方法并不是问题。</code></pre><p>165. 没有奇迹般地提高生产力的秘诀</p><pre><code>- 不要轻信市面上那些宣称能够将生产力提高50%、75%甚至100%的工具、语言或方法。</code></pre><p>166. 理解进度的含义</p><pre><code>- BCWP(Budgeted cost of work performed)，衡量目前已经完成的工作的预算- ACWP(Actual cost of work performed)，衡量目前的实际开销- BCWE(Budgeted cost of work expected)，衡量你预期的开销- (BCWP-BCWE)/BCWE, 技术状态，大于0表示进度提前，小于0表示进度delay- (BCWP-ACWP)/BCWP, 预算状态，大于0表示低于预算，小于0表示高于预算</code></pre><p>167. 通过偏差进行管理</p><pre><code>- 很多项目经理在汇报进度时总是花很多时间讲述他们做的有多好，这些话应该留在项目结束后的荣誉时刻再说。项目进行中，应该着重汇报实际进展与初始计划的偏差，这样注意力和资源才会被用于解决问题。</code></pre><p>168. 不要过度紧张你的硬件</p><pre><code>- 硬件的确会对软件产生很大的影响，当你有充足的硬件资源时，可以忽略这条原则；当你需要争取每一块内存、每一个cpu时，记得要相应调整软件开发的时间表。</code></pre><p>169. 乐观看待硬件的发展<br>170. 悲观看待软件的发展<br>171. 认为灾难是不可能的想法往往导致灾难</p><pre><code>- 过度自信往往是很多灾难的原因。</code></pre><p>172. 要进行项目的事后分析</p><pre><code>- 每个项目进行过程中都会遇到各种各样的问题，项目结束后应该及时检讨、总结经验教训，以期下次做的更好！</code></pre><blockquote><p>refer:《201 principles of software development》</p></blockquote>]]></content>
      
      <categories>
          
          <category> software engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> engineer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 添加订阅、搜索和站点地图</title>
      <link href="/2018/04/22/Hexo-%E6%B7%BB%E5%8A%A0%E8%AE%A2%E9%98%85%E3%80%81%E6%90%9C%E7%B4%A2%E5%92%8C%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/"/>
      <url>/2018/04/22/Hexo-%E6%B7%BB%E5%8A%A0%E8%AE%A2%E9%98%85%E3%80%81%E6%90%9C%E7%B4%A2%E5%92%8C%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>简单记录下如何给Hexo网站添加RSS订阅功能、站内搜索功能以及站点地图。这些功能都需要相应的插件支持(Hexo插件参见 <a href="https://hexo.io/plugins/)" target="_blank" rel="noopener">https://hexo.io/plugins/)</a>, 然后修改配置文件，<strong>最后需要重新部署</strong>。</p><h2 id="添加RSS订阅功能"><a href="#添加RSS订阅功能" class="headerlink" title="添加RSS订阅功能"></a>添加RSS订阅功能</h2><ol><li>安装插件<br><code>npm install hexo-generator-feed --save</code></li><li>在站点配置文件<code>_config.yml</code>中追加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: &apos; &apos;</span><br></pre></td></tr></table></figure></li></ol><ul><li>type - Feed type. (atom/rss2)</li><li>path - Feed path. (Default: atom.xml/rss2.xml)</li><li>limit - Maximum number of posts in the feed (Use 0 or false to show all posts)</li><li>hub - URL of the PubSubHubbub hubs (Leave it empty if you don’t use it)</li><li>content - (optional) set to ‘true’ to include the contents of the entire post in the feed.</li><li>content_limit - (optional) Default length of post content used in summary. Only used, if content setting is false and no custom post description present.</li><li>content_limit_delim - (optional) If content_limit is used to shorten post contents, only cut at the last occurrence of this delimiter before reaching the character limit. Not used by default.</li></ul><h2 id="添加站内搜索功能"><a href="#添加站内搜索功能" class="headerlink" title="添加站内搜索功能"></a>添加站内搜索功能</h2><ol><li>安装插件<br><code>npm install hexo-generator-search --save</code></li><li>在站点配置文件<code>_config.yml</code>中追加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Search站内搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br></pre></td></tr></table></figure></li></ol><ul><li>path - file path. By default is search.xml . If the file extension is .json, the output format will be JSON. Otherwise XML format file will be exported.</li><li>field - the search scope you want to search, you can chose:<ul><li>post (Default) - will only covers all the posts of your blog.</li><li>page - will only covers all the pages of your blog.</li><li>all - will covers all the posts and pages of your blog.</li></ul></li></ul><h2 id="添加站点地图-Sitemap"><a href="#添加站点地图-Sitemap" class="headerlink" title="添加站点地图(Sitemap)"></a>添加站点地图(Sitemap)</h2><p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的Sitemap形式，就是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p><p>简言之， Sitemap 对于搜索引擎优化(Search Engine Optimization，即SEO) 非常重要，在网站中加入 Sitemap 有利于搜索引擎的爬虫组件的抓取和收录网站内容。以下插件主要用于生成适用于谷歌和百度的sitemap文件。 </p><h5 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save // 生成sitemap.xml</span><br><span class="line">hexo-generator-seo-friendly-sitemap --save // seo优化sitemap.xml</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save // 生成baidusitemap.xml</span><br></pre></td></tr></table></figure><h5 id="2-在站点配置文件-config-yml中追加如下代码："><a href="#2-在站点配置文件-config-yml中追加如下代码：" class="headerlink" title="2. 在站点配置文件_config.yml中追加如下代码："></a>2. 在站点配置文件<code>_config.yml</code>中追加如下代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># SiteMap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>部署(<code>hexo g</code>)之后，如果public目录下生成了 sitemap.xml 和 baidusitemap.xml 就表示配置成功了。</p><h5 id="3-验证网站，并提交sitemap文件"><a href="#3-验证网站，并提交sitemap文件" class="headerlink" title="3. 验证网站，并提交sitemap文件"></a>3. 验证网站，并提交sitemap文件</h5><p>在我们向搜索引擎提交 sitemap 之前，搜索引擎需要先验证我们对网站的所有权。两个搜索引擎的验证入口分别为:</p><ul><li><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Google Search Console</a></li><li><a href="https://ziyuan.baidu.com/dashboard/index" target="_blank" rel="noopener">百度站长平台</a></li></ul><p>具体验证及提交方法请参考:</p><ul><li><a href="http://selfmaking.top/2017/01/01/hexo-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-%E4%B8%89-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95/" target="_blank" rel="noopener">hexo 系列教程: (三) 搜索引擎收录</a> </li><li><a href="http://tengj.top/2016/03/14/hexo6seo/" target="_blank" rel="noopener">hexo干货系列: (六) hexo提交搜索引擎（百度+谷歌</a></li></ul>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello 我的半亩花田</title>
      <link href="/2018/04/15/Hello-myBlog/"/>
      <url>/2018/04/15/Hello-myBlog/</url>
      <content type="html"><![CDATA[<p>大二暑假在csdn上注册了自己的第一个博客，从写题解开始，零零碎碎记了一些东西，但并没有坚持更博～<br>研究生之后因为比较忙，更是任自己的博客成了一片荒地～直到找工作时，才又开始写题解～<br>很早以前就想要建一个自己的独立博客，然而却因为忙一推再推…好吧，明明就是太懒…😅</p><p>今天我的Blog终于落成了！虽然还差一个域名…后面再补…😅</p><p><img src="/images/little_prince.jpg" alt="little prince"></p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li></ul>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/04/hello-world/"/>
      <url>/2018/04/04/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
